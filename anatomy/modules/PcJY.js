/**
 * id: PcJY
 * path: ./cas
 */

(function(require,module,exports) {
"use strict";function e(e,r,t){var a=n(e,e.VERTEX_SHADER,r),o=n(e,e.FRAGMENT_SHADER,t),c=e.createProgram();if(null==c)throw Error("Can't create shader program");if(e.attachShader(c,a),e.attachShader(c,o),e.linkProgram(c),!e.getProgramParameter(c,e.LINK_STATUS))throw Error("Unable to initialize the shader program");return c}function n(e,n,r){var t=e.createShader(n);if(null==t)throw Error("Can't create shader");if(e.shaderSource(t,r),e.compileShader(t),!e.getShaderParameter(t,e.COMPILE_STATUS)){var a=e.getShaderInfoLog(t);throw e.deleteShader(t),Error(null!=a?a:"An error occurred compiling the shaders")}return t}function r(e,n,r){e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r),e.drawArrays(e.TRIANGLES,0,6)}function t(e){var n=e.createTexture();if(null==n)throw Error("Could not create texture");e.bindTexture(e.TEXTURE_2D,n);var r=e.RGBA,t=e.RGBA,a=e.UNSIGNED_BYTE,o=new Uint8Array([0,0,255,255]);return e.texImage2D(e.TEXTURE_2D,0,r,1,1,0,t,a,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),n}Object.defineProperty(exports,"__esModule",{value:!0}),exports.videoCAS=void 0;var a=[-1,1,-1,-1,1,-1,1,-1,1,1,-1,1],o=[0,1,0,0,1,0,1,0,1,1,0,1];function c(n,r,t){if(null==n)throw Error("Cant create gl context");var c=e(n,g,v);n.useProgram(c),n.uniform1f(n.getUniformLocation(c,"srcWidth"),r),n.uniform1f(n.getUniformLocation(c,"srcHeight"),t),n.uniform1i(n.getUniformLocation(c,"frameTexture"),0);var i=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,i),n.bufferData(n.ARRAY_BUFFER,new Float32Array(a),n.STATIC_DRAW);var f=n.getAttribLocation(c,"aPos");n.vertexAttribPointer(f,2,n.FLOAT,!1,2*Float32Array.BYTES_PER_ELEMENT,0),n.enableVertexAttribArray(f);var l=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,l),n.bufferData(n.ARRAY_BUFFER,new Float32Array(o),n.STATIC_DRAW);var p=n.getAttribLocation(c,"aTexCoord");n.vertexAttribPointer(p,2,n.FLOAT,!1,2*Float32Array.BYTES_PER_ELEMENT,0),n.enableVertexAttribArray(p)}function i(e,n){function r(){e.width=n.videoWidth,e.height=n.videoHeight;["width","height","position","left","top","zIndex","overflow"].forEach(function(r){e.style[r]=n.style[r]});var r=n.style.objectFit;e.style.objectFit=0===r.length?"contain":r}r();var t=new MutationObserver(function(e){e.some(function(e){return"style"===e.attributeName})&&r()});return t.observe(n,{attributes:!0}),function(){t.disconnect()}}function f(e){var n=document.createElement("canvas");if("VIDEO"!==e.tagName)return{canvas:n,supported:!1,stop:function(){}};var a=i(n,e),o=e.style.display,f=!0,v=null,g=n.getContext("webgl2");null==g?p():(c(g,e.videoWidth,e.videoHeight),e.style.display="none",v=t(g),function n(){if(null==g||null==v)return;r(g,v,e);l=requestAnimationFrame(n)}());var l=0;function p(){a(),null==n||n.remove(),e.style.display=o,f=!1,cancelAnimationFrame(l)}return{canvas:n,supported:f,stop:p}}exports.videoCAS=f;var v="#version 300 es\n// Copyright (c) 2023 Bilibili Inc. All rights reserved.\n// ======================================================================\n// Bili Mobile Super Resolution [BMSR] - scaling & sharpening & vibrance\n// v0.2.6\n// ======================================================================\nprecision highp float;\nout vec4 FragColor;\n\nin vec2 TexCoord;\n\nuniform sampler2D frameTexture;\nuniform float srcWidth; //input width\nuniform float srcHeight; //input height\nconst float usmCoeff = 1.2; // for usm v2, range [1.0, 1.5]\nconst float upperCoeff = 0.5; // range [0.0, 1.0]\nconst float lowerCoeff = 0.5; // range [0.0, 1.0]\nconst float vibCoeff = 0.15; // range [0.0, 0.5)\nconst float brightCoeff = 0.15; // range [0.0, 0.3]\n\nconst float lobe = 0.25; // default 0.25\nconst vec3 grayMat = vec3(0.299, 0.587, 0.114); // rgb to gray\nconst float eps = 1.0e-8;\n\n// ATTENTION: the texture coordinates is assumed to be the same as image pixel coordinates as follows:\n// 0------------------\x3e\n// |                  x\n// |\n// |\n// |\n// |\n// v  y\n\n// +---+---+---+\n// | a | b | c |\n// +---+---+---+\n// | d | e | f |\n// +---+---+---+\n// | g | h | i |\n// +---+---+---+\nvoid calcMeanVar(\n    inout vec3 aMean,\n    inout vec3 aVar,\n    float w,\n    vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f, vec3 g, vec3 h, vec3 i\n) {\n    vec3 sum = a + b + c + d + e + f + g + h + i;\n    vec3 mean = sum / 9.0;\n    vec3 sum2 = a * a + b * b + c * c + d * d + e * e + f * f + g * g + h * h + i * i;\n    vec3 var = sum2 / 9.0 - mean * mean;\n    aMean += w * mean;\n    aVar += w * var;\n}\n\nvoid vibranceV2(\n    inout vec3 rgbUSM,\n    vec3 rgbRS\n) {\n    float rgbMax = max(rgbRS.r, max(rgbRS.g, rgbRS.b));\n    float rgbMin = min(rgbRS.r, min(rgbRS.g, rgbRS.b));\n    float delta = rgbMax - rgbMin;\n    float flag = step(eps, delta);\n    float value = rgbMax + rgbMin;\n    float L = value / 2.0; // L from HSL\n    float S = delta / abs(2.0 * step(0.5, L) - value);\n    float alpha = 1.0 / clamp(1.0 - vibCoeff, S, 1.0) - 1.0;\n    rgbUSM = rgbUSM + flag * alpha * (rgbUSM - L);\n}\n\n// lanczos2 function is approximated as the following polynomial\n// (25/16 * (2/5 * x^2 - 1)^2 - (25/16 - 1)) * (1/4 * x^2 - 1)^2 = (1.5625 * (0.4 * x^2 - 1)^2 - 0.5625) * (0.25 * x^2 - 1)^2\nvoid lanczos2(\n    inout vec3 aC,\n    inout float aW,\n    vec2 off,\n    vec3 c\n) {\n    vec2 wA = 0.4 * off * off - 1.0;\n    wA = 1.5625 * wA * wA - 0.5625;\n    vec2 wB = lobe * off * off - 1.0;\n    wB *= wB;\n    wB *= wA;\n    float w = wB.x * wB.y;\n    aC += w * c;\n    aW += w;\n}\n\n//  +---+---+---+---+\n//  | a | b | c | d |\n//  +---F---+---+---+\n//  | e | f-|-g | h |\n//  +---+-|-+-|-+---+\n//  | i | j-|-k | l |\n//  +---+---+---+---+\n//  | m | n | o | p |\n//  +---+---+---+---+\n// the interpolated pixel is within the square of fgkj\nvoid main() {\n    /**************************************************\n    step 1: upsample\n    ***************************************************/\n    vec2 invSrc = vec2(1.0 / srcWidth, 1.0 / srcHeight);\n    vec2 pp = TexCoord * vec2(srcWidth, srcHeight) - 0.5; // output texture coordinate in the input pixel coordinate\n    vec2 fp = floor(pp); // fp is F in the pixel coordinate\n    pp -= fp; // offset to the top left f\n    fp = fp + 0.5; // make fp being the pixel coordinate corresponding to f in the texture coordinate\n\n    vec3 aC = texture(frameTexture, (fp + vec2(-1.0, -1.0)) * invSrc).rgb;\n    vec3 bC = texture(frameTexture, (fp + vec2(0.0, -1.0)) * invSrc).rgb;\n    vec3 cC = texture(frameTexture, (fp + vec2(1.0, -1.0)) * invSrc).rgb;\n    vec3 dC = texture(frameTexture, (fp + vec2(2.0, -1.0)) * invSrc).rgb;\n    vec3 eC = texture(frameTexture, (fp + vec2(-1.0, 0.0)) * invSrc).rgb;\n    vec3 fC = texture(frameTexture, fp * invSrc).rgb;\n    vec3 gC = texture(frameTexture, (fp + vec2(1.0, 0.0)) * invSrc).rgb;\n    vec3 hC = texture(frameTexture, (fp + vec2(2.0, 0.0)) * invSrc).rgb;\n    vec3 iC = texture(frameTexture, (fp + vec2(-1.0, 1.0)) * invSrc).rgb;\n    vec3 jC = texture(frameTexture, (fp + vec2(0.0, 1.0)) * invSrc).rgb;\n    vec3 kC = texture(frameTexture, (fp + vec2(1.0, 1.0)) * invSrc).rgb;\n    vec3 lC = texture(frameTexture, (fp + vec2(2.0, 1.0)) * invSrc).rgb;\n    vec3 mC = texture(frameTexture, (fp + vec2(-1.0, 2.0)) * invSrc).rgb;\n    vec3 nC = texture(frameTexture, (fp + vec2(0.0, 2.0)) * invSrc).rgb;\n    vec3 oC = texture(frameTexture, (fp + vec2(1.0, 2.0)) * invSrc).rgb;\n    vec3 pC = texture(frameTexture, (fp + vec2(2.0, 2.0)) * invSrc).rgb;\n\n    vec3 rgbRS = vec3(0.0);\n    float aW = 0.0;\n    lanczos2(rgbRS, aW, vec2(-1.0, -1.0) - pp, aC);\n    lanczos2(rgbRS, aW, vec2(0.0, -1.0) - pp, bC);\n    lanczos2(rgbRS, aW, vec2(1.0, -1.0) - pp, cC);\n    lanczos2(rgbRS, aW, vec2(2.0, -1.0) - pp, dC);\n    lanczos2(rgbRS, aW, vec2(-1.0, 0.0) - pp, eC);\n    lanczos2(rgbRS, aW, vec2(0.0, 0.0) - pp, fC);\n    lanczos2(rgbRS, aW, vec2(1.0, 0.0) - pp, gC);\n    lanczos2(rgbRS, aW, vec2(2.0, 0.0) - pp, hC);\n    lanczos2(rgbRS, aW, vec2(-1.0, 1.0) - pp, iC);\n    lanczos2(rgbRS, aW, vec2(0.0, 1.0) - pp, jC);\n    lanczos2(rgbRS, aW, vec2(1.0, 1.0) - pp, kC);\n    lanczos2(rgbRS, aW, vec2(2.0, 1.0) - pp, lC);\n    lanczos2(rgbRS, aW, vec2(-1.0, 2.0) - pp, mC);\n    lanczos2(rgbRS, aW, vec2(0.0, 2.0) - pp, nC);\n    lanczos2(rgbRS, aW, vec2(1.0, 2.0) - pp, oC);\n    lanczos2(rgbRS, aW, vec2(2.0, 2.0) - pp, pC);\n    rgbRS /= aW;\n    rgbRS = clamp(rgbRS, 0.0, 1.0);\n\n    /**************************************************\n    step 2: sharpen\n    ***************************************************/\n    vec3 mean = vec3(0.0);\n    vec3 var = vec3(0.0);\n    calcMeanVar(mean, var, (1.0 - pp.x) * (1.0 - pp.y), aC, bC, cC, eC, fC, gC, iC, jC, kC);\n    calcMeanVar(mean, var, pp.x * (1.0 - pp.y), bC, cC, dC, fC, gC, hC, jC, kC, lC);\n    calcMeanVar(mean, var, (1.0 - pp.x) * pp.y, eC, fC, gC, iC, jC, kC, mC, nC, oC);\n    calcMeanVar(mean, var, pp.x * pp.y, fC, gC, hC, jC, kC, lC, nC, oC, pC);\n    vec3 W = usmCoeff + 1.0 / (var + 1.0);\n    vec3 rgbUSM = mean + W * (rgbRS - mean);\n    /**************\n    step2.1: suppression v2 it's better for suppressing white edge\n    **************/\n    vec3 diff = rgbUSM - rgbRS;\n    vec3 rgbRS2 = rgbRS * rgbRS;\n    vec3 maxDiff = 0.508809 * rgbRS2 * rgbRS2 - 1.32485 * rgbRS2 * rgbRS + 1.124863 * rgbRS2 - 0.386092 * rgbRS + 0.077532;\n    rgbUSM = rgbRS + min(diff, maxDiff);\n    rgbUSM = clamp(rgbUSM, 0.0, 1.0);\n\n    /**************************************************\n    step 3: vibrance\n    ***************************************************/\n    vibranceV2(rgbUSM, rgbRS);\n    rgbUSM = -brightCoeff * rgbUSM * rgbUSM + (1.0 + brightCoeff) * rgbUSM;\n    FragColor = vec4(rgbUSM, 1.0);\n}",g="#version 300 es\nlayout (location = 0) in vec2 aPos;\nlayout (location = 1) in vec2 aTexCoord;\n\nout vec2 TexCoord;\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 0.0, 1.0);\n    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);\n}";
})()